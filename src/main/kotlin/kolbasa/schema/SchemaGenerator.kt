package kolbasa.schema

import kolbasa.cluster.Shard
import kolbasa.queue.Queue
import kolbasa.queue.QueueHelpers
import kolbasa.queue.meta.MetaField
import kolbasa.queue.meta.MetaIndexType
import kolbasa.schema.Table.Companion.hasIndex
import kolbasa.utils.TimeHelper

internal object SchemaGenerator {

    internal fun generateTableSchema(queue: Queue<*>, existingTable: Table?, idRange: IdRange): Schema {
        val mutableSchema = MutableSchema()

        // table
        forTable(queue, existingTable, mutableSchema, idRange)

        // table sequence
        forIdentity(existingTable, mutableSchema, idRange)

        // shard column
        forShard(queue, existingTable, mutableSchema)

        // scheduledAt column
        forScheduledAtColumn(queue, existingTable, mutableSchema)

        // attempts
        forRemainingAttemptsColumn(queue, existingTable, mutableSchema)

        // metadata
        queue.metadata.fields.forEach { metaField ->
            forMetaFieldColumn(queue, metaField, existingTable, mutableSchema)
        }

        return Schema(mutableSchema.tables, mutableSchema.indexes)
    }

    internal fun generateRenameTableSchema(queue: Queue<*>, existingTable: Table?, newQueueName: String): Schema {
        if (existingTable == null) {
            // Rename only existing tables
            return Schema.EMPTY
        }

        val newDatabaseTableName = QueueHelpers.generateQueueDbName(newQueueName)
        val renameSql = "alter table if exists ${queue.dbTableName} RENAME TO $newDatabaseTableName"
        return Schema(tableStatements = listOf(renameSql), indexStatements = emptyList())
    }

    internal fun generateDropTableSchema(queue: Queue<*>, existingTable: Table?): Schema {
        if (existingTable == null) {
            // Drop only existing tables
            return Schema.EMPTY
        }

        val dropSql = "drop table if exists ${queue.dbTableName}"
        return Schema(tableStatements = listOf(dropSql), indexStatements = emptyList())
    }

    private fun forTable(queue: Queue<*>, existingTable: Table?, mutableSchema: MutableSchema, idRange: IdRange) {
        val createTableStatement = """
            create table if not exists ${queue.dbTableName}(
                ${Const.ID_COLUMN_NAME} bigint generated by default as identity (minvalue ${idRange.min} maxvalue ${idRange.max} cache ${idRange.cache} cycle) primary key,
                ${Const.USELESS_COUNTER_COLUMN_NAME} int,
                ${Const.OPENTELEMETRY_COLUMN_NAME} varchar(${Const.OPENTELEMETRY_VALUE_LENGTH})[],
                ${Const.SHARD_COLUMN_NAME} int not null default ${Shard.MIN_SHARD},
                ${Const.CREATED_AT_COLUMN_NAME} timestamp not null default clock_timestamp(),
                ${Const.SCHEDULED_AT_COLUMN_NAME} timestamp not null,
                ${Const.PROCESSING_AT_COLUMN_NAME} timestamp,
                ${Const.PRODUCER_COLUMN_NAME} varchar(${Const.PRODUCER_CONSUMER_VALUE_MAX_LENGTH}),
                ${Const.CONSUMER_COLUMN_NAME} varchar(${Const.PRODUCER_CONSUMER_VALUE_MAX_LENGTH}),
                ${Const.REMAINING_ATTEMPTS_COLUMN_NAME} int not null,
                ${Const.DATA_COLUMN_NAME} ${queue.databaseDataType.dbColumnType} not null
            )
            """.trimIndent()

        if (existingTable == null) {
            mutableSchema.tables += createTableStatement
        }
    }

    private fun forIdentity(existingTable: Table?, mutableSchema: MutableSchema, idRange: IdRange) {
        if (existingTable == null) {
            // If table does not exist, we can't adjust identity column because there is no such column
            // CREATE TABLE statement will create identity column with the desired settings automatically
            return
        }

        val needToAlterIdentity = (existingTable.identity.min != idRange.min) ||
            (existingTable.identity.max != idRange.max) ||
            (existingTable.identity.cache != idRange.cache)

        val alterSequenceStatement = """
                alter sequence ${existingTable.identity.name}
                restart with ${idRange.min}
                start with ${idRange.min}
                minvalue ${idRange.min}
                maxvalue ${idRange.max}
                cache ${idRange.cache}
                cycle
            """.trimIndent()

        if (needToAlterIdentity) {
            mutableSchema.tables += alterSequenceStatement
        }
    }

    private fun forShard(queue: Queue<*>, existingTable: Table?, mutableSchema: MutableSchema) {
        val indexName = queue.dbTableName + "_" + Const.SHARD_COLUMN_NAME
        val indexStatement =
            "create index concurrently if not exists $indexName on ${queue.dbTableName}(${Const.SHARD_COLUMN_NAME})"

        val hasIndex = existingTable.hasIndex(indexName)
        if (!hasIndex) {
            mutableSchema.indexes += indexStatement
        }
    }

    private fun forScheduledAtColumn(queue: Queue<*>, existingTable: Table?, mutableSchema: MutableSchema) {
        val hasDefaultClause = existingTable
            ?.findColumn(Const.SCHEDULED_AT_COLUMN_NAME)
            ?.defaultExpression != null

        if (queue.options.defaultDelay.isZero) {
            val alterStatement =
                "alter table ${queue.dbTableName} alter ${Const.SCHEDULED_AT_COLUMN_NAME} set default clock_timestamp()"

            if (existingTable != null && hasDefaultClause) {
                mutableSchema.tables += alterStatement
            }
        } else {
            val alterStatement = """
                    alter table ${queue.dbTableName}
                    alter ${Const.SCHEDULED_AT_COLUMN_NAME}
                    set default clock_timestamp() + ${TimeHelper.generatePostgreSQLInterval(queue.options.defaultDelay)}
                """.trimIndent()

            if (!hasDefaultClause) {
                mutableSchema.tables += alterStatement
            }
        }

        // index
        val indexName = queue.dbTableName + "_" + Const.SCHEDULED_AT_COLUMN_NAME
        val indexStatement =
            "create index concurrently if not exists $indexName on ${queue.dbTableName}(${Const.SCHEDULED_AT_COLUMN_NAME})"

        val hasIndex = existingTable.hasIndex(indexName)
        if (!hasIndex) {
            mutableSchema.indexes += indexStatement
        }
    }

    private fun forRemainingAttemptsColumn(queue: Queue<*>, existingTable: Table?, mutableSchema: MutableSchema) {
        val desiredAttempts = queue.options.defaultAttempts
        val currentDefaultClause = existingTable
            ?.findColumn(Const.REMAINING_ATTEMPTS_COLUMN_NAME)
            ?.defaultExpression

        val alterStatement =
            "alter table ${queue.dbTableName} alter ${Const.REMAINING_ATTEMPTS_COLUMN_NAME} set default $desiredAttempts"

        if (desiredAttempts.toString() != currentDefaultClause) {
            mutableSchema.tables += alterStatement
        }
    }

    private fun forMetaFieldColumn(
        queue: Queue<*>,
        metaField: MetaField<*>,
        existingTable: Table?,
        mutableSchema: MutableSchema
    ) {
        val hasColumn = existingTable?.findColumn(metaField.dbColumnName) != null
        val alterStatement =
            "alter table ${queue.dbTableName} add if not exists ${metaField.dbColumnName} ${metaField.dbColumnType}"

        if (!hasColumn) {
            mutableSchema.tables += alterStatement
        }

        // index
        val justIndexName = QueueHelpers.generateMetaColumnIndexName(queue.dbTableName, metaField.name, "j")
        val strictUniqueIndexName = QueueHelpers.generateMetaColumnIndexName(queue.dbTableName, metaField.name, "su")
        val pendingUniqueIndexName = QueueHelpers.generateMetaColumnIndexName(queue.dbTableName, metaField.name, "pu")

        val hasJustIndex = existingTable.hasIndex(justIndexName)
        val hasStrictUniqueIndex = existingTable.hasIndex(strictUniqueIndexName)
        val hasPendingUniqueIndex = existingTable.hasIndex(pendingUniqueIndexName)

        val dropJustIndexStatement = "drop index concurrently if exists $justIndexName"
        val dropStrictUniqueIndexStatement = "drop index concurrently if exists $strictUniqueIndexName"
        val dropPendingUniqueIndexStatement = "drop index concurrently if exists $pendingUniqueIndexName"

        when (metaField.dbIndexType) {
            MetaIndexType.NO_INDEX -> {
                // NO_INDEX means we need to drop all existing indexes if they exist
                if (existingTable != null) {
                    if (hasJustIndex) {
                        mutableSchema.indexes += dropJustIndexStatement
                    }
                    if (hasStrictUniqueIndex) {
                        mutableSchema.indexes += dropStrictUniqueIndexStatement
                    }
                    if (hasPendingUniqueIndex) {
                        mutableSchema.indexes += dropPendingUniqueIndexStatement
                    }
                }
            }

            MetaIndexType.JUST_INDEX -> {
                val createIndexStatement =
                    "create index concurrently if not exists $justIndexName on ${queue.dbTableName}(${metaField.dbColumnName})"

                if (!hasJustIndex) {
                    mutableSchema.indexes += createIndexStatement
                }
                if (hasStrictUniqueIndex) {
                    mutableSchema.indexes += dropStrictUniqueIndexStatement
                }
                if (hasPendingUniqueIndex) {
                    mutableSchema.indexes += dropPendingUniqueIndexStatement
                }
            }

            MetaIndexType.STRICT_UNIQUE_INDEX -> {
                val createIndexStatement = """
                    create unique index concurrently if not exists $strictUniqueIndexName
                    on ${queue.dbTableName}(${metaField.dbColumnName})
                    where (${Const.REMAINING_ATTEMPTS_COLUMN_NAME} > 0)
                """.trimIndent()

                if (hasJustIndex) {
                    mutableSchema.indexes += dropJustIndexStatement
                }
                if (!hasStrictUniqueIndex) {
                    mutableSchema.indexes += createIndexStatement
                }
                if (hasPendingUniqueIndex) {
                    mutableSchema.indexes += dropPendingUniqueIndexStatement
                }
            }

            MetaIndexType.PENDING_UNIQUE_INDEX -> {
                val createIndexStatement = """
                    create unique index concurrently if not exists $pendingUniqueIndexName
                    on ${queue.dbTableName}(${metaField.dbColumnName})
                    where (${Const.REMAINING_ATTEMPTS_COLUMN_NAME} > 0) and (${Const.PROCESSING_AT_COLUMN_NAME} is null)
                """.trimIndent()

                if (hasJustIndex) {
                    mutableSchema.indexes += dropJustIndexStatement
                }
                if (hasStrictUniqueIndex) {
                    mutableSchema.indexes += dropStrictUniqueIndexStatement
                }
                if (!hasPendingUniqueIndex) {
                    mutableSchema.indexes += createIndexStatement
                }
            }
        }
    }
}

// Just a holder class for a few mutable lists
private class MutableSchema {
    val tables = mutableListOf<String>()
    val indexes = mutableListOf<String>()
}

