package kolbasa.schema

import kolbasa.cluster.Shard
import kolbasa.queue.Queue
import kolbasa.queue.QueueHelpers
import kolbasa.queue.QueueOptions
import kolbasa.queue.meta.MetaField
import kolbasa.queue.meta.MetaIndexType
import kolbasa.utils.TimeHelper

internal object SchemaGenerator {

    internal fun generateTableSchema(queue: Queue<*>, existingTable: Table?, idRange: IdRange): Schema {
        val mutableSchema = MutableSchema()

        // table
        forTable(queue, existingTable, mutableSchema, idRange)

        // table sequence
        forIdentity(existingTable, mutableSchema, idRange)

        // shard column
        forShard(queue, existingTable, mutableSchema)

        // scheduledAt column
        forScheduledAtColumn(queue, existingTable, mutableSchema)

        // attempts
        forRemainingAttemptsColumn(queue, existingTable, mutableSchema)

        // metadata
        queue.metadata.fields.forEach { metaField ->
            forMetaFieldColumn(queue, metaField, existingTable, mutableSchema)
        }

        return Schema(mutableSchema.tables, mutableSchema.indexes)
    }

    private fun forTable(queue: Queue<*>, existingTable: Table?, mutableSchema: MutableSchema, idRange: IdRange) {
        val createTableStatement = """
            create table if not exists ${queue.dbTableName}(
                ${Const.ID_COLUMN_NAME} bigint generated by default as identity (minvalue ${idRange.min} maxvalue ${idRange.max} cache ${idRange.cache} cycle) primary key,
                ${Const.USELESS_COUNTER_COLUMN_NAME} int,
                ${Const.OPENTELEMETRY_COLUMN_NAME} varchar(${Const.OPENTELEMETRY_VALUE_LENGTH})[],
                ${Const.SHARD_COLUMN_NAME} int not null,
                ${Const.CREATED_AT_COLUMN_NAME} timestamp not null default clock_timestamp(),
                ${Const.SCHEDULED_AT_COLUMN_NAME} timestamp not null,
                ${Const.PROCESSING_AT_COLUMN_NAME} timestamp,
                ${Const.PRODUCER_COLUMN_NAME} varchar(${Const.PRODUCER_CONSUMER_VALUE_MAX_LENGTH}),
                ${Const.CONSUMER_COLUMN_NAME} varchar(${Const.PRODUCER_CONSUMER_VALUE_MAX_LENGTH}),
                ${Const.REMAINING_ATTEMPTS_COLUMN_NAME} int not null,
                ${Const.DATA_COLUMN_NAME} ${queue.databaseDataType.dbColumnType} not null
            )
            """.trimIndent()

        if (existingTable == null) {
            mutableSchema.tables += createTableStatement
        }
    }

    private fun forIdentity(
        existingTable: Table?,
        mutableSchema: MutableSchema,
        idRange: IdRange
    ) {
        if (existingTable == null) {
            // If table does not exist, we can't adjust identity column because there is no such column
            // CREATE TABLE statement will create identity column with the desired settings automatically
            return
        }

        val needToAlterIdentity = (existingTable.identity.min != idRange.min) ||
            (existingTable.identity.max != idRange.max) ||
            (existingTable.identity.cache != idRange.cache)

        val alterSequenceStatement = """
                alter sequence ${existingTable.identity.name}
                restart with ${idRange.min}
                start with ${idRange.min}
                minvalue ${idRange.min}
                maxvalue ${idRange.max}
                cache ${idRange.cache}
                cycle
            """.trimIndent()

        if (needToAlterIdentity) {
            mutableSchema.tables += alterSequenceStatement
        }
    }


    private fun forShard(queue: Queue<*>, existingTable: Table?, mutableSchema: MutableSchema) {
        val hasColumn = existingTable?.findColumn(Const.SHARD_COLUMN_NAME) != null
        val shardColumn = """
            alter table ${queue.dbTableName}
            add if not exists ${Const.SHARD_COLUMN_NAME} int not null default ${Shard.MIN_SHARD}
        """.trimIndent()

        if (!hasColumn) {
            mutableSchema.tables += shardColumn
        }

        // index
        val indexName = queue.dbTableName + "_" + Const.SHARD_COLUMN_NAME
        val indexStatement = """
                create index concurrently if not exists $indexName
                on ${queue.dbTableName}(${Const.SHARD_COLUMN_NAME})
            """.trimIndent()

        val hasIndex = existingTable?.findIndex(indexName) != null
        if (!hasIndex) {
            mutableSchema.indexes += indexStatement
        }
    }

    private fun forScheduledAtColumn(queue: Queue<*>, existingTable: Table?, mutableSchema: MutableSchema) {
        val hasDefaultClause = existingTable
            ?.findColumn(Const.SCHEDULED_AT_COLUMN_NAME)
            ?.defaultExpression != null

        if (queue.options == null || queue.options.defaultDelay.isZero) {
            val alterStatement = """
                    alter table ${queue.dbTableName}
                    alter ${Const.SCHEDULED_AT_COLUMN_NAME}
                    set default clock_timestamp()
                """.trimIndent()

            if (existingTable != null && hasDefaultClause) {
                mutableSchema.tables += alterStatement
            }
        } else {
            val alterStatement = """
                    alter table ${queue.dbTableName}
                    alter ${Const.SCHEDULED_AT_COLUMN_NAME}
                    set default clock_timestamp() + ${TimeHelper.generatePostgreSQLInterval(queue.options.defaultDelay)}
                """.trimIndent()

            if (!hasDefaultClause) {
                mutableSchema.tables += alterStatement
            }
        }

        // index
        val indexName = queue.dbTableName + "_" + Const.SCHEDULED_AT_COLUMN_NAME
        val indexStatement = """
                create index concurrently if not exists $indexName
                on ${queue.dbTableName}(${Const.SCHEDULED_AT_COLUMN_NAME})
            """.trimIndent()

        val hasIndex = existingTable?.findIndex(indexName) != null
        if (!hasIndex) {
            mutableSchema.indexes += indexStatement
        }
    }

    private fun forRemainingAttemptsColumn(queue: Queue<*>, existingTable: Table?, mutableSchema: MutableSchema) {
        val desiredAttempts = queue.options?.defaultAttempts ?: QueueOptions.DEFAULT_ATTEMPTS
        val currentDefaultClause = existingTable
            ?.findColumn(Const.REMAINING_ATTEMPTS_COLUMN_NAME)
            ?.defaultExpression

        val alterStatement = """
                alter table ${queue.dbTableName}
                alter ${Const.REMAINING_ATTEMPTS_COLUMN_NAME}
                set default $desiredAttempts
            """.trimIndent()

        if (desiredAttempts.toString() != currentDefaultClause) {
            mutableSchema.tables += alterStatement
        }
    }

    private fun forMetaFieldColumn(
        queue: Queue<*>,
        metaField: MetaField<*>,
        existingTable: Table?,
        mutableSchema: MutableSchema
    ) {
        val hasColumn = existingTable?.findColumn(metaField.dbColumnName) != null
        val alterStatement = """
            alter table ${queue.dbTableName}
            add if not exists ${metaField.dbColumnName} ${metaField.dbColumnType}
        """.trimIndent()
        if (!hasColumn) {
            mutableSchema.tables += alterStatement
        }

        // index
        val oldIndexName = queue.dbTableName + "_" + metaField.dbColumnName // old format, to be removed later
        val justIndexName = QueueHelpers.generateMetaColumnIndexName(queue.dbTableName, metaField.name, "j")
        val strictUniqueIndexName = QueueHelpers.generateMetaColumnIndexName(queue.dbTableName, metaField.name, "su")
        val pendingUniqueIndexName = QueueHelpers.generateMetaColumnIndexName(queue.dbTableName, metaField.name, "pu")

        val oldIndex = existingTable?.findIndex(oldIndexName)
        val justIndex = existingTable?.findIndex(justIndexName)
        val strictUniqueIndex = existingTable?.findIndex(strictUniqueIndexName)
        val pendingUniqueIndex = existingTable?.findIndex(pendingUniqueIndexName)

        val dropOldIndexStatement = "drop index concurrently if exists $oldIndexName"
        val dropJustIndexStatement = "drop index concurrently if exists $justIndexName"
        val dropStrictUniqueIndexStatement = "drop index concurrently if exists $strictUniqueIndexName"
        val dropPendingUniqueIndexStatement = "drop index concurrently if exists $pendingUniqueIndexName"

        // Remove old index format, delete these lines after migration
        if (existingTable != null && oldIndex != null) {
            mutableSchema.indexes += dropOldIndexStatement
        }

        when (metaField.dbIndexType) {
            MetaIndexType.NO_INDEX -> {
                if (existingTable != null) {
                    if (justIndex != null) {
                        mutableSchema.indexes += dropJustIndexStatement
                    }
                    if (strictUniqueIndex != null) {
                        mutableSchema.indexes += dropStrictUniqueIndexStatement
                    }
                    if (pendingUniqueIndex != null) {
                        mutableSchema.indexes += dropPendingUniqueIndexStatement
                    }
                }
            }

            MetaIndexType.JUST_INDEX -> {
                val createIndexStatement = """
                    create index concurrently if not exists $justIndexName
                    on ${queue.dbTableName}(${metaField.dbColumnName})
                """.trimIndent()

                if (justIndex == null) {
                    mutableSchema.indexes += createIndexStatement
                }
                if (strictUniqueIndex != null) {
                    mutableSchema.indexes += dropStrictUniqueIndexStatement
                }
                if (pendingUniqueIndex != null) {
                    mutableSchema.indexes += dropPendingUniqueIndexStatement
                }
            }

            MetaIndexType.STRICT_UNIQUE_INDEX -> {
                val createIndexStatement = """
                    create unique index concurrently if not exists $strictUniqueIndexName
                    on ${queue.dbTableName}(${metaField.dbColumnName})
                    where (${Const.REMAINING_ATTEMPTS_COLUMN_NAME} > 0)
                """.trimIndent()

                if (justIndex != null) {
                    mutableSchema.indexes += dropJustIndexStatement
                }
                if (strictUniqueIndex == null) {
                    mutableSchema.indexes += createIndexStatement
                }
                if (pendingUniqueIndex != null) {
                    mutableSchema.indexes += dropPendingUniqueIndexStatement
                }
            }

            MetaIndexType.PENDING_UNIQUE_INDEX -> {
                val createIndexStatement = """
                    create unique index concurrently if not exists $pendingUniqueIndexName
                    on ${queue.dbTableName}(${metaField.dbColumnName})
                    where (${Const.REMAINING_ATTEMPTS_COLUMN_NAME} > 0) and (${Const.PROCESSING_AT_COLUMN_NAME} is null)
                """.trimIndent()

                if (justIndex != null) {
                    mutableSchema.indexes += dropJustIndexStatement
                }
                if (strictUniqueIndex != null) {
                    mutableSchema.indexes += dropStrictUniqueIndexStatement
                }
                if (pendingUniqueIndex == null) {
                    mutableSchema.indexes += createIndexStatement
                }
            }
        }
    }


    // Just a holder class for a few mutable lists
    private class MutableSchema {
        val tables = mutableListOf<String>()
        val indexes = mutableListOf<String>()
    }

}

